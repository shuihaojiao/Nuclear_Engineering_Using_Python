# 有限差分泊松方程类型
https://www.bilibili.com/video/BV1QnVUzgEU3/?spm_id_from=333.337.search-card.all.click&vd_source=891137c33fd05c91613840a7ab4d0c6a

**这段代码使用 Taichi 编程语言实现了一个二维泊松方程 (Poisson's equation) 的求解器。它通过雅可比迭代法 (Jacobi method) 在一个 N x N 的网格上对该方程进行数值求解，并提供了实时可视化或性能基准测试的功能。**

---

### ## 🎯 主要功能
该程序旨在解决形如 `∇²x = b` 的二维泊松方程，这是物理和工程中一个非常基础的偏微分方程，常用于描述电势、引力场、热传导和流体压力等问题。

*   **x**: 未知的标量场（代码中的 `self.x`），是程序要求解的目标。
*   **b**: 已知的源项（代码中的 `self.b`）。
*   **∇²**: 拉普拉斯算子，代表场的二阶空间导数。

### ## ⚙️ 核心算法
程序采用了以下两种数值方法：

1.  **有限差分法 (Finite Difference Method)**
    *   将连续的二维空间离散化为一个 `N x N` 的网格。
    *   使用中心差分近似拉普拉斯算子：`∇²x ≈ (x[i+1,j] + x[i-1,j] + x[i,j+1] + x[i,j-1] - 4*x[i,j]) / dx²`。
    *   这样，偏微分方程就被转化成了一个大型线性方程组。

2.  **雅可比迭代法 (Jacobi Method)**
    *   这是一种经典的迭代算法，用于求解线性方程组。
    *   `substep` 内核中的核心更新公式正是雅可比法的体现：
        ```python
        self.xt[i,j] = (-self.b[i,j]*self.dx**2 + self.x[i+1,j] + self.x[i-1,j] + self.x[i,j+1] + self.x[i,j-1]) / 4.0
        ```
    *   在每次迭代中，它使用邻居节点的 **旧值** (`self.x`) 来计算当前节点的 **新值** (`self.xt`)。
    *   `while True` 循环不断执行这个迭代过程，使得解 `x` 逐步收敛到真实解。

### ## 📂 代码结构解析

*   `PoissonSolver` 类: 封装了求解器的所有状态和操作。
    *   `self.x`: 存储当前迭代的解。
    *   `self.b`: 存储源项 `b(x, y) = sin(πx) * sin(πy)`。
    *   `self.xt`: 一个临时缓存，用于存储下一次迭代的解，避免在同一步迭代中数据读写冲突。
*   `@ti.kernel`: Taichi 的装饰器，它会将修饰的 Python 函数编译成高性能的并行代码（在 CPU 或 GPU 上运行）。
*   `init()`: 初始化内核，将解 `x` 初始化为 0，并设置源项 `b` 的值。
*   `substep()`: 计算内核，执行单次雅可比迭代。
*   `main()`: 主函数，负责创建求解器实例，并在一个无限循环中不断调用 `step()` 来推进求解过程。
*   `argparse`: 命令行参数解析。允许用户在运行时指定网格大小 `N`、浮点数精度（`fp32` 或 `fp64`）以及运行模式。
